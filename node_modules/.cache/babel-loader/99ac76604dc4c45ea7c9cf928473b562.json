{"ast":null,"code":"var pkgVersion = require(\"./package.json\").version;\n\nvar Ajv = require(\"ajv\");\n\nvar util = require(\"util\");\n\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\n\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\n\nvar abiSchema = require(\"./spec/abi.spec.json\");\n/**\n * Property definitions for Contract Objects\n *\n * Describes canonical output properties as sourced from some \"dirty\" input\n * object. Describes normalization process to account for deprecated and/or\n * nonstandard keys and values.\n *\n * Maps (key -> property) where:\n *  - `key` is the top-level output key matching up with those in the schema\n *  - `property` is an object with optional values:\n *      - `sources`: list of sources (see below); default `key`\n *      - `transform`: function(value) -> transformed value; default x -> x\n *\n * Each source represents a means to select a value from dirty object.\n * Allows:\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\n *    object\n *  - function(dirtyObj) -> (cleanValue | undefined)\n *\n * The optional `transform` parameter standardizes value regardless of source,\n * for purposes of ensuring data type and/or string schemas.\n */\n// helper that ensures abi's do not contain function signatures\n\n\nconst sanitizedValue = dirtyValueArray => {\n  let sanitizedValueArray = [];\n  dirtyValueArray.forEach(item => {\n    let sanitizedItem = Object.assign({}, item);\n    delete sanitizedItem.signature;\n    sanitizedValueArray.push(sanitizedItem);\n  });\n  return sanitizedValueArray;\n}; // filter `signature` property from an event\n\n\nconst sanitizeEvent = dirtyEvent => Object.entries(dirtyEvent).reduce((acc, [property, value]) => property === \"signature\" ? acc : Object.assign(acc, {\n  [property]: value\n}), {}); // sanitize aggregrate events given a `network-object.spec.json#events` object\n\n\nconst sanitizeAllEvents = dirtyEvents => Object.entries(dirtyEvents).reduce((acc, [property, event]) => Object.assign(acc, {\n  [property]: sanitizeEvent(event)\n}), {});\n\nvar properties = {\n  contractName: {\n    sources: [\"contractName\", \"contract_name\"]\n  },\n  abi: {\n    sources: [\"abi\", \"interface\"],\n    transform: function (value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (e) {\n          value = undefined;\n        }\n      }\n\n      if (Array.isArray(value)) {\n        return sanitizedValue(value);\n      }\n\n      return value;\n    }\n  },\n  metadata: {\n    sources: [\"metadata\"]\n  },\n  bytecode: {\n    sources: [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  deployedBytecode: {\n    sources: [\"deployedBytecode\", \"runtimeBytecode\", \"evm.deployedBytecode.object\"],\n    transform: function (value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n\n      return value;\n    }\n  },\n  sourceMap: {\n    sources: [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  deployedSourceMap: {\n    sources: [\"deployedSourceMap\", \"srcmapRuntime\", \"evm.deployedBytecode.sourceMap\"]\n  },\n  source: {},\n  sourcePath: {},\n  ast: {},\n  legacyAST: {\n    transform: function (value, obj) {\n      var schemaVersion = obj.schemaVersion || \"0.0.0\"; // legacyAST introduced in v2.0.0\n\n      if (schemaVersion[0] < 2) {\n        return obj.ast;\n      } else {\n        return value;\n      }\n    }\n  },\n  compiler: {},\n  networks: {\n    /**\n     * Normalize a networks object. Currently this makes sure `events` are\n     * always sanitized and `links` is extracted when copying from\n     * a TruffleContract context object.\n     *\n     * @param {object} value - the target object\n     * @param {object | TruffleContract} obj - the context, or source object.\n     * @return {object} The normalized Network object\n     */\n    transform: function (value = {}, obj) {\n      // Sanitize value's events for known networks\n      Object.keys(value).forEach(networkId => {\n        if (value[networkId].events) {\n          value[networkId].events = sanitizeAllEvents(value[networkId].events);\n        }\n      }); // Set and sanitize the current networks property from the\n      // TruffleContract. Note: obj is a TruffleContract if it has\n      // `network_id` attribute\n\n      const networkId = obj.network_id;\n\n      if (networkId && value.hasOwnProperty(networkId)) {\n        value[networkId].links = obj.links;\n        value[networkId].events = sanitizeAllEvents(obj.events);\n      }\n\n      return value;\n    }\n  },\n  schemaVersion: {\n    sources: [\"schemaVersion\", \"schema_version\"]\n  },\n  updatedAt: {\n    sources: [\"updatedAt\", \"updated_at\"],\n    transform: function (value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n\n      return value;\n    }\n  },\n  networkType: {},\n  devdoc: {},\n  userdoc: {}\n};\n/**\n * Construct a getter for a given key, possibly applying some post-retrieve\n * transformation on the resulting value.\n *\n * @return {Function} Accepting dirty object and returning value || undefined\n */\n\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function (x) {\n      return x;\n    };\n  }\n\n  return function (obj) {\n    try {\n      return transform(obj[key]);\n    } catch (e) {\n      return undefined;\n    }\n  };\n}\n/**\n * Chains together a series of function(obj) -> value, passing resulting\n * returned value to next function in chain.\n *\n * Accepts any number of functions passed as arguments\n * @return {Function} Accepting initial object, returning end-of-chain value\n *\n * Assumes all intermediary values to be objects, with well-formed sequence\n * of operations.\n */\n\n\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function (obj) {\n    return getters.reduce(function (cur, get) {\n      return get(cur);\n    }, obj);\n  };\n} // Schema module\n//\n\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function (contractObj) {\n    var ajv = new Ajv({\n      verbose: true\n    });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      const message = `Schema validation failed. Errors:\\n\\n${ajv.errors.map(({\n        keyword,\n        dataPath,\n        schemaPath,\n        params,\n        message,\n        data,\n        schema,\n        // eslint-disable-line no-unused-vars\n        parentSchema\n      }) => util.format(\"%s (%s):\\n%s\\n\", message, keyword, util.inspect({\n        dataPath,\n        schemaPath,\n        params,\n        data,\n        parentSchema\n      }, {\n        depth: 5\n      }))).join(\"\\n\")}`;\n      const error = new Error(message);\n      error.errors = ajv.errors;\n      throw error;\n    }\n  },\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function (objDirty, options) {\n    options = options || {};\n    var normalized = {}; // iterate over each property\n\n    Object.keys(properties).forEach(function (key) {\n      var property = properties[key];\n      var value; // normalized value || undefined\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n\n      var sources = property.sources || [key]; // iterate over sources until value is defined or end of list met\n\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i]; // string refers to path to value in objDirty, split and chain\n        // getters\n\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\").map(function (k) {\n            return getter(k);\n          });\n          source = chain.apply(null, traversals);\n        } // source should be a function that takes the objDirty and returns\n        // value or undefined\n\n\n        value = source(objDirty);\n      } // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n\n\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      } // add resulting (possibly undefined) to normalized obj\n\n\n      normalized[key] = value;\n    }); // Copy x- options\n\n    Object.keys(objDirty).forEach(function (key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    }); // update schema version\n\n    normalized.schemaVersion = pkgVersion;\n\n    if (options.validate) {\n      this.validate(normalized);\n    }\n\n    return normalized;\n  }\n};\nmodule.exports = TruffleContractSchema;","map":{"version":3,"sources":["/home/eke/patient-eth/node_modules/@truffle/contract-schema/index.js"],"names":["pkgVersion","require","version","Ajv","util","contractObjectSchema","networkObjectSchema","abiSchema","sanitizedValue","dirtyValueArray","sanitizedValueArray","forEach","item","sanitizedItem","Object","assign","signature","push","sanitizeEvent","dirtyEvent","entries","reduce","acc","property","value","sanitizeAllEvents","dirtyEvents","event","properties","contractName","sources","abi","transform","JSON","parse","e","undefined","Array","isArray","metadata","bytecode","indexOf","deployedBytecode","sourceMap","deployedSourceMap","source","sourcePath","ast","legacyAST","obj","schemaVersion","compiler","networks","keys","networkId","events","network_id","hasOwnProperty","links","updatedAt","Date","toISOString","networkType","devdoc","userdoc","getter","key","x","chain","getters","prototype","slice","call","arguments","cur","get","TruffleContractSchema","validate","contractObj","ajv","verbose","addSchema","message","errors","map","keyword","dataPath","schemaPath","params","data","schema","parentSchema","format","inspect","depth","join","error","Error","normalize","objDirty","options","normalized","i","length","traversals","split","k","apply","module","exports"],"mappings":"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","sourcesContent":["var pkgVersion = require(\"./package.json\").version;\nvar Ajv = require(\"ajv\");\nvar util = require(\"util\");\n\nvar contractObjectSchema = require(\"./spec/contract-object.spec.json\");\nvar networkObjectSchema = require(\"./spec/network-object.spec.json\");\nvar abiSchema = require(\"./spec/abi.spec.json\");\n\n/**\n * Property definitions for Contract Objects\n *\n * Describes canonical output properties as sourced from some \"dirty\" input\n * object. Describes normalization process to account for deprecated and/or\n * nonstandard keys and values.\n *\n * Maps (key -> property) where:\n *  - `key` is the top-level output key matching up with those in the schema\n *  - `property` is an object with optional values:\n *      - `sources`: list of sources (see below); default `key`\n *      - `transform`: function(value) -> transformed value; default x -> x\n *\n * Each source represents a means to select a value from dirty object.\n * Allows:\n *  - dot-separated (`.`) string, corresponding to path to value in dirty\n *    object\n *  - function(dirtyObj) -> (cleanValue | undefined)\n *\n * The optional `transform` parameter standardizes value regardless of source,\n * for purposes of ensuring data type and/or string schemas.\n */\n\n// helper that ensures abi's do not contain function signatures\nconst sanitizedValue = dirtyValueArray => {\n  let sanitizedValueArray = [];\n  dirtyValueArray.forEach(item => {\n    let sanitizedItem = Object.assign({}, item);\n    delete sanitizedItem.signature;\n    sanitizedValueArray.push(sanitizedItem);\n  });\n  return sanitizedValueArray;\n};\n\n// filter `signature` property from an event\nconst sanitizeEvent = dirtyEvent =>\n  Object.entries(dirtyEvent).reduce(\n    (acc, [property, value]) =>\n      property === \"signature\"\n        ? acc\n        : Object.assign(acc, { [property]: value }),\n    {}\n  );\n\n// sanitize aggregrate events given a `network-object.spec.json#events` object\nconst sanitizeAllEvents = dirtyEvents =>\n  Object.entries(dirtyEvents).reduce(\n    (acc, [property, event]) =>\n      Object.assign(acc, { [property]: sanitizeEvent(event) }),\n    {}\n  );\n\nvar properties = {\n  contractName: {\n    sources: [\"contractName\", \"contract_name\"]\n  },\n  abi: {\n    sources: [\"abi\", \"interface\"],\n    transform: function(value) {\n      if (typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (e) {\n          value = undefined;\n        }\n      }\n      if (Array.isArray(value)) {\n        return sanitizedValue(value);\n      }\n      return value;\n    }\n  },\n  metadata: {\n    sources: [\"metadata\"]\n  },\n  bytecode: {\n    sources: [\"bytecode\", \"binary\", \"unlinked_binary\", \"evm.bytecode.object\"],\n    transform: function(value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  deployedBytecode: {\n    sources: [\n      \"deployedBytecode\",\n      \"runtimeBytecode\",\n      \"evm.deployedBytecode.object\"\n    ],\n    transform: function(value) {\n      if (value && value.indexOf(\"0x\") !== 0) {\n        value = \"0x\" + value;\n      }\n      return value;\n    }\n  },\n  sourceMap: {\n    sources: [\"sourceMap\", \"srcmap\", \"evm.bytecode.sourceMap\"]\n  },\n  deployedSourceMap: {\n    sources: [\n      \"deployedSourceMap\",\n      \"srcmapRuntime\",\n      \"evm.deployedBytecode.sourceMap\"\n    ]\n  },\n  source: {},\n  sourcePath: {},\n  ast: {},\n  legacyAST: {\n    transform: function(value, obj) {\n      var schemaVersion = obj.schemaVersion || \"0.0.0\";\n\n      // legacyAST introduced in v2.0.0\n      if (schemaVersion[0] < 2) {\n        return obj.ast;\n      } else {\n        return value;\n      }\n    }\n  },\n  compiler: {},\n  networks: {\n    /**\n     * Normalize a networks object. Currently this makes sure `events` are\n     * always sanitized and `links` is extracted when copying from\n     * a TruffleContract context object.\n     *\n     * @param {object} value - the target object\n     * @param {object | TruffleContract} obj - the context, or source object.\n     * @return {object} The normalized Network object\n     */\n    transform: function(value = {}, obj) {\n      // Sanitize value's events for known networks\n      Object.keys(value).forEach(networkId => {\n        if (value[networkId].events) {\n          value[networkId].events = sanitizeAllEvents(value[networkId].events);\n        }\n      });\n\n      // Set and sanitize the current networks property from the\n      // TruffleContract. Note: obj is a TruffleContract if it has\n      // `network_id` attribute\n      const networkId = obj.network_id;\n      if (networkId && value.hasOwnProperty(networkId)) {\n        value[networkId].links = obj.links;\n        value[networkId].events = sanitizeAllEvents(obj.events);\n      }\n\n      return value;\n    }\n  },\n  schemaVersion: {\n    sources: [\"schemaVersion\", \"schema_version\"]\n  },\n  updatedAt: {\n    sources: [\"updatedAt\", \"updated_at\"],\n    transform: function(value) {\n      if (typeof value === \"number\") {\n        value = new Date(value).toISOString();\n      }\n      return value;\n    }\n  },\n  networkType: {},\n  devdoc: {},\n  userdoc: {}\n};\n\n/**\n * Construct a getter for a given key, possibly applying some post-retrieve\n * transformation on the resulting value.\n *\n * @return {Function} Accepting dirty object and returning value || undefined\n */\nfunction getter(key, transform) {\n  if (transform === undefined) {\n    transform = function(x) {\n      return x;\n    };\n  }\n\n  return function(obj) {\n    try {\n      return transform(obj[key]);\n    } catch (e) {\n      return undefined;\n    }\n  };\n}\n\n/**\n * Chains together a series of function(obj) -> value, passing resulting\n * returned value to next function in chain.\n *\n * Accepts any number of functions passed as arguments\n * @return {Function} Accepting initial object, returning end-of-chain value\n *\n * Assumes all intermediary values to be objects, with well-formed sequence\n * of operations.\n */\nfunction chain() {\n  var getters = Array.prototype.slice.call(arguments);\n  return function(obj) {\n    return getters.reduce(function(cur, get) {\n      return get(cur);\n    }, obj);\n  };\n}\n\n// Schema module\n//\n\nvar TruffleContractSchema = {\n  // Return a promise to validate a contract object\n  // - Resolves as validated `contractObj`\n  // - Rejects with list of errors from schema validator\n  validate: function(contractObj) {\n    var ajv = new Ajv({ verbose: true });\n    ajv.addSchema(abiSchema);\n    ajv.addSchema(networkObjectSchema);\n    ajv.addSchema(contractObjectSchema);\n    if (ajv.validate(\"contract-object.spec.json\", contractObj)) {\n      return contractObj;\n    } else {\n      const message = `Schema validation failed. Errors:\\n\\n${ajv.errors\n        .map(\n          ({\n            keyword,\n            dataPath,\n            schemaPath,\n            params,\n            message,\n            data,\n            schema, // eslint-disable-line no-unused-vars\n            parentSchema\n          }) =>\n            util.format(\n              \"%s (%s):\\n%s\\n\",\n              message,\n              keyword,\n              util.inspect(\n                {\n                  dataPath,\n                  schemaPath,\n                  params,\n                  data,\n                  parentSchema\n                },\n                { depth: 5 }\n              )\n            )\n        )\n        .join(\"\\n\")}`;\n      const error = new Error(message);\n      error.errors = ajv.errors;\n      throw error;\n    }\n  },\n\n  // accepts as argument anything that can be turned into a contract object\n  // returns a contract object\n  normalize: function(objDirty, options) {\n    options = options || {};\n    var normalized = {};\n\n    // iterate over each property\n    Object.keys(properties).forEach(function(key) {\n      var property = properties[key];\n      var value; // normalized value || undefined\n\n      // either used the defined sources or assume the key will only ever be\n      // listed as its canonical name (itself)\n      var sources = property.sources || [key];\n\n      // iterate over sources until value is defined or end of list met\n      for (var i = 0; value === undefined && i < sources.length; i++) {\n        var source = sources[i];\n        // string refers to path to value in objDirty, split and chain\n        // getters\n        if (typeof source === \"string\") {\n          var traversals = source.split(\".\").map(function(k) {\n            return getter(k);\n          });\n          source = chain.apply(null, traversals);\n        }\n\n        // source should be a function that takes the objDirty and returns\n        // value or undefined\n        value = source(objDirty);\n      }\n\n      // run source-agnostic transform on value\n      // (e.g. make sure bytecode begins 0x)\n      if (property.transform) {\n        value = property.transform(value, objDirty);\n      }\n\n      // add resulting (possibly undefined) to normalized obj\n      normalized[key] = value;\n    });\n\n    // Copy x- options\n    Object.keys(objDirty).forEach(function(key) {\n      if (key.indexOf(\"x-\") === 0) {\n        normalized[key] = getter(key)(objDirty);\n      }\n    });\n\n    // update schema version\n    normalized.schemaVersion = pkgVersion;\n\n    if (options.validate) {\n      this.validate(normalized);\n    }\n\n    return normalized;\n  }\n};\n\nmodule.exports = TruffleContractSchema;\n"]},"metadata":{},"sourceType":"script"}